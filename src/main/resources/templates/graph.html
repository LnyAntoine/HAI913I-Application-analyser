<!DOCTYPE html>
<html lang="fr" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Application Analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>
    <style>
        #calculatorResults ul { list-style: none; padding: 0; }
        #calculatorResults li { margin-bottom: 0.7em; }
        #graph { margin-top: 2em; text-align: center; }
        .zoomControls { text-align: center; margin: 0.5em 0; }
        .zoomControls button { cursor: pointer; }
        /* wrapper pour séparer contrôles et zone scrollable */
        .graphBlock { margin-top: 2em; max-width:90vw; }
        /* viewport scrollable séparée des contrôles : garder taille fixe et box-sizing pour éviter décalage quand scrollbar apparaît */
        .graphViewport { text-align:left; overflow-x:auto; overflow-y:auto; max-width:90vw; max-height:70vh; min-height:30px; padding:0; box-sizing:border-box; }
        /* s'assurer que les contrôles restent visibles et ne sont pas recouverts */
        .zoomControls { position: sticky; top: 0; z-index: 999; width: 100%; box-sizing: border-box; background: rgba(255,255,255,0.95); padding: 6px 8px; display:flex; justify-content:center; gap:8px; align-items:center; border-bottom: 1px solid rgba(0,0,0,0.06); }
        /* boutons plus lisibles */
        .zoomControls button { margin: 0; padding: 6px 10px; }
        .zoomControls input[type="range"] { vertical-align: middle; }
        /* TITLES: hidden by default — will be shown when graph is rendered */
        .graphTitle { display: none; margin-bottom: 6px; }
        .graphTitle h3 { margin: 0; font-size: 1.05em; }
        /* Directory list */
        .dirEntry { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
        .dirEntry input[type="text"] { flex:1; }
        .dirEntry button { width:28px, height:28px; padding:0; }
        #addDirBtn { margin-left:4px; }
    </style>
</head>
<body>
    <h1>Générateur de graphe d'appels</h1>
    <form id="dirForm">
        <fieldset id="directoryFieldset" style="border:none;padding:0;margin:0 0 8px 0;">
            <legend style="font-weight:normal;margin-bottom:6px;">Chemin du dossier :</legend>
            <!-- container pour plusieurs chemins -->
            <div id="directoryList">
                <div class="dirEntry">
                    <input type="text" id="directory_0" name="directory" required placeholder="Chemin du dossier (ex : C:\\monProjet)">
                    <button type="button" id="addDirBtn">+</button>
                </div>
            </div>
        </fieldset>
        <!-- déplacer le label à l'intérieur du container pour qu'il soit masqué avec l'input -->
        <div id="xContainer">
            <label for="x">Valeur de X :</label>
            <input type="number" id="x" name="x" value="0" min="0" required>
        </div>
        <label for="analysisType">Type d'analyse :</label>
        <select id="analysisType" name="analysisType">
            <option value="all">Tout</option>
            <option value="statistics">Statistiques</option>
            <option value="coupling">Couplage</option>
            <option value="clustering">Clustering</option>
            <option value="modules">Modules</option>
            <option value="calling">Appels</option>
        </select>
        <div id="cpContainer">
            <label for="cp">CP (pour clustering) :</label>
            <input type="number" id="cp" name="cp" value="0.5" step="0.01" min="0" max="1">
            <span id="cpHint" style="margin-left:8px;color:#666;font-size:0.9em"></span>
        </div>
        <!-- container pour fichiers à exclure (liste dynamique) -->
        <div id="excludedContainer" style="margin-top:8px;">
            <label>Fichier à exclure :</label>
            <div id="excludedList">
                <div class="dirEntry">
                    <input type="text" name="excluded" id="excluded_0" placeholder="ex: com.example.MyClass">
                    <button type="button" id="addExcludedBtn">+</button>
                </div>
            </div>
        </div>
         <button type="submit">Analyser l'application</button>
     </form>
    <div id="calculatorResults"></div>

    <!-- Call graph block -->
    <div class="graphBlock" id="callBlock">
        <div class="graphTitle"><h3>Appels</h3></div>
        <div class="zoomControls" id="zoomControls_graph" style="display:none;"></div>
        <div id="graphContainer" class="graphViewport">
            <div id="graph"></div>
        </div>
    </div>

    <!-- Coupling block -->
    <div class="graphBlock" id="couplingBlock">
        <div class="graphTitle"><h3>Couplage</h3></div>
        <div class="zoomControls" id="zoomControls_coupling" style="display:none;"></div>
        <div id="couplingGraphContainer" class="graphViewport">
            <div id="couplingGraph"></div>
        </div>
    </div>

    <!-- Clustering block -->
    <div class="graphBlock" id="clusteringBlock">
        <div class="graphTitle"><h3>Clustering (dendrogramme)</h3></div>
        <div class="zoomControls" id="zoomControls_clustering" style="display:none;"></div>
        <div id="clusteringGraphContainer" class="graphViewport">
            <div id="clusteringGraph"></div>
        </div>
    </div>

    <!-- Modules block placed below clustering -->
    <div class="graphBlock" id="modulesBlock">
        <div class="graphTitle"><h3>Modules</h3></div>
        <div class="zoomControls" id="zoomControls_modules" style="display:none;"></div>
        <div id="modulesGraphContainer" class="graphViewport">
            <div id="modulesGraph"></div>
        </div>
    </div>

    <script>
        const titles = document.querySelectorAll('.graphTitle');
        titles.forEach(t => t.style.display = 'none');

        // current selection (utilisé pour décider quel(s) titre(s) afficher)
        let currentAnalysisType = null;

        // --- gestion des inputs directory multiples ---
        function addDirectoryInput(value) {
            const list = document.getElementById('directoryList');
            const entry = document.createElement('div');
            entry.className = 'dirEntry';
            const index = list.querySelectorAll('input[name="directory"]').length;
            const input = document.createElement('input');
            input.type = 'text';
            input.name = 'directory';
            input.id = 'directory_' + index;
            input.placeholder = 'Chemin du dossier (ex : C:\\monProjet)';
            if (value) input.value = value;
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() { removeDirectoryInput(entry); };
            entry.appendChild(input);
            entry.appendChild(removeBtn);
            list.appendChild(entry);
        }
        function removeDirectoryInput(entry) {
            const list = document.getElementById('directoryList');
            const inputs = list.querySelectorAll('input[name="directory"]');
            if (inputs.length <= 1) {
                // si dernier input, on le vide mais on ne le supprime pas
                inputs[0].value = '';
                return;
            }
            list.removeChild(entry);
        }
        function getDirectoryParams() {
            const inputs = document.querySelectorAll('input[name="directory"]');
            const parts = [];
            inputs.forEach(inp => {
                const v = inp.value.trim();
                if (v) parts.push('directory=' + encodeURIComponent(v));
            });
            return parts.join('&');
        }
        // attacher le bouton + initial
        document.getElementById('addDirBtn').addEventListener('click', function(){ addDirectoryInput(); });

        // --- gestion des inputs excluded multiples ---
        function addExcludedInput(value) {
            const list = document.getElementById('excludedList');
            const entry = document.createElement('div');
            entry.className = 'dirEntry';
            const index = list.querySelectorAll('input[name="excluded"]').length;
            const input = document.createElement('input');
            input.type = 'text';
            input.name = 'excluded';
            input.id = 'excluded_' + index;
            input.placeholder = 'ex: com.example.MyClass';
            if (value) input.value = value;
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.textContent = '−';
            removeBtn.onclick = function() { removeExcludedInput(entry); };
            entry.appendChild(input);
            entry.appendChild(removeBtn);
            list.appendChild(entry);
        }
        function removeExcludedInput(entry) {
            const list = document.getElementById('excludedList');
            const inputs = list.querySelectorAll('input[name="excluded"]');
            if (inputs.length <= 1) { inputs[0].value = ''; return; }
            list.removeChild(entry);
        }
        function getExcludedParams() {
            const inputs = document.querySelectorAll('input[name="excluded"]');
            const parts = [];
            inputs.forEach(inp => {
                const v = inp.value.trim();
                if (v) parts.push('excluded=' + encodeURIComponent(v));
            });
            return parts.join('&');
        }
        // attacher le bouton + initial pour excluded
        document.getElementById('addExcludedBtn').addEventListener('click', function(){ addExcludedInput(); });

        // Met à jour la visibilité des titres selon le type et les données renvoyées par le serveur
        function updateTitlesForResponse(type, data) {
            const titleMap = {
                calling: document.querySelector('#callBlock .graphTitle'),
                coupling: document.querySelector('#couplingBlock .graphTitle'),
                clustering: document.querySelector('#clusteringBlock .graphTitle'),
                modules: document.querySelector('#modulesBlock .graphTitle')
            };
            // masquer toutes
            Object.values(titleMap).forEach(t => { if (t) t.style.display = 'none'; });

            if (type === 'statistics') {
                // rien à afficher pour statistics
                return;
            }

            if (type === 'all') {
                if (data.callGraphData) titleMap.calling && (titleMap.calling.style.display = 'block');
                if (data.couplingGraphData) titleMap.coupling && (titleMap.coupling.style.display = 'block');
                if (data.clusterGraphData) titleMap.clustering && (titleMap.clustering.style.display = 'block');
                if (data.modulesGraphData) titleMap.modules && (titleMap.modules.style.display = 'block');
                return;
            }

            // cas d'un type spécifique
            if (type === 'calling' && data.callGraphData) {
                titleMap.calling && (titleMap.calling.style.display = 'block');
            } else if (type === 'coupling' && data.couplingGraphData) {
                titleMap.coupling && (titleMap.coupling.style.display = 'block');
            } else if (type === 'clustering' && data.clusterGraphData) {
                titleMap.clustering && (titleMap.clustering.style.display = 'block');
            } else if (type === 'modules') {
                if (data.modulesGraphData) titleMap.modules && (titleMap.modules.style.display = 'block');
                else if (data.clusterGraphData) titleMap.clustering && (titleMap.clustering.style.display = 'block');
            }
        }

        document.getElementById('dirForm').onsubmit = async function(e) {
            e.preventDefault();
            // const dir = document.getElementById('directory').value;
            const x = document.getElementById('x').value;
            const type = document.getElementById('analysisType').value;
            const cp = document.getElementById('cp').value;

            // au moins un chemin non vide
            const dirParams = getDirectoryParams();
            if (!dirParams) {
                alert('Veuillez renseigner au moins un chemin de dossier.');
                return;
            }
            // récupérer excluded (peut être vide)
            const excludedParams = getExcludedParams();

            // mémoriser le type sélectionné (sera utilisé après réception de la réponse)
            currentAnalysisType = type;

            // Clear previous graphs and hide zoom controls
            document.getElementById('graph').innerHTML = '';
            document.getElementById('couplingGraph').innerHTML = '';
            document.getElementById('clusteringGraph').innerHTML = '';
            document.getElementById('modulesGraph').innerHTML = '';
            document.getElementById('calculatorResults').innerHTML = '';
            document.getElementById('zoomControls_graph').style.display = 'none';
            document.getElementById('zoomControls_coupling').style.display = 'none';
            document.getElementById('zoomControls_clustering').style.display = 'none';
            document.getElementById('zoomControls_modules').style.display = 'none';

            let url = '/getGraph';
            // inclure excludedParams si présents
            let body = dirParams + (excludedParams ? '&' + excludedParams : '') + '&x=' + encodeURIComponent(x);

            if (type === 'calling') {
                url = '/analyze/calling';
                body = dirParams + (excludedParams ? '&' + excludedParams : '');
            } else if (type === 'coupling') {
                url = '/analyze/coupling';
                body = dirParams + (excludedParams ? '&' + excludedParams : '');
            } else if (type === 'clustering') {
                url = '/analyze/clustering';
                body = dirParams + (excludedParams ? '&' + excludedParams : '') + '&cp=' + encodeURIComponent(cp);
            } else if (type === 'modules') {
                // reuse clustering endpoint which will now also return modulesGraphData
                // use dedicated modules endpoint
                url = '/analyze/modules';
                body = dirParams + (excludedParams ? '&' + excludedParams : '') + '&cp=' + encodeURIComponent(cp);
            } else if (type === 'statistics') {
                url = '/analyze/statistics';
                body = dirParams + (excludedParams ? '&' + excludedParams : '') + '&x=' + encodeURIComponent(x);
            }
            // Si 'all' est choisi, on envoie cp pour que le graphe de modules en tienne compte
            if (type === 'all') {
                // conserver endpoint combiné (/getGraph) mais ajouter cp au body
                body += '&cp=' + encodeURIComponent(cp);
            }

            const response = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: body
            });
            const data = await response.json();

            // Attendre la réponse du serveur avant de mettre à jour les titres
            updateTitlesForResponse(type, data);

            // Data peut contenir différentes clefs selon l'endpoint
            if (data.statisticData) {
                const stat = data.statisticData;
                if (stat.result && stat.order) {
                    showCalculatorResults(stat.result, stat.order);
                } else if (stat.statisticData) {
                    showCalculatorResults(stat.statisticData.result, stat.statisticData.order);
                } else {
                    showCalculatorResults(stat.result || stat, stat.order || []);
                }
            }

            // Rendu en fonction du choix
            if (type === 'all') {
                if (data.callGraphData) drawCallingGraph(data.callGraphData);
                if (data.couplingGraphData) drawCouplingGraphViz(data.couplingGraphData);
                if (data.clusterGraphData) drawClusteringGraphViz(data.clusterGraphData);
                if (data.modulesGraphData) drawModulesGraphViz(data.modulesGraphData);
            } else if (type === 'modules') {
                if (data.modulesGraphData) drawModulesGraphViz(data.modulesGraphData);
                else if (data.clusterGraphData) drawClusteringGraphViz(data.clusterGraphData);
            } else {
                if (data.callGraphData) drawCallingGraph(data.callGraphData);
                if (data.couplingGraphData) drawCouplingGraphViz(data.couplingGraphData);
                if (data.clusterGraphData) drawClusteringGraphViz(data.clusterGraphData);
            }
        };

        function showCalculatorResults(results, order) {
            const div = document.getElementById('calculatorResults');
            if (!results) { div.innerHTML = ''; return; }
            let html = '<h2>Résultats Calculator</h2><ul>';
            for (const key of order) {
                if (results[key]) {
                    html += `<li><b>${key}</b> : <pre style="display:inline">${results[key]}</pre></li>`;
                }
            }
            html += '</ul>';
            div.innerHTML = html;
        }

        function addZoomControlsFor(containerId, svg) {
            if (!svg) return;
            const controlsId = 'zoomControls_' + containerId;
            const controls = document.getElementById(controlsId);
            // build controls HTML
            controls.innerHTML = '';
            const btnOut = document.createElement('button'); btnOut.type = 'button'; btnOut.textContent = '-';
            const range = document.createElement('input'); range.type = 'range'; range.min = '0.1'; range.max = '8'; range.step = '0.01'; range.value = '0.8';
            const btnIn = document.createElement('button'); btnIn.type = 'button'; btnIn.textContent = '+';
            controls.appendChild(btnOut); controls.appendChild(range); controls.appendChild(btnIn);
            controls.style.display = 'block';
            function setZoom(val) {
                svg.style.transform = `scale(${val})`;
                svg.style.transformOrigin = 'top left';
            }
            range.oninput = function() { setZoom(this.value); };
            btnIn.onclick = function() { let v = Math.min(8, parseFloat(range.value) + 0.1); range.value = v; setZoom(v); };
            btnOut.onclick = function() { let v = Math.max(0.1, parseFloat(range.value) - 0.1); range.value = v; setZoom(v); };
            setZoom(range.value);
        }

        function drawClusteringGraphViz(dot){
            try {
                const viz = new Viz();
                viz.renderSVGElement(dot).then(function(element) {
                    element.style.maxWidth = '100%'; element.style.height = 'auto'; element.style.width = '100%';
                    element.style.display = 'block'; element.style.margin = '0'; element.style.padding = '0';
                    element.classList.add('graphSvg');
                    document.getElementById('clusteringGraph').appendChild(element);
                    addZoomControlsFor('clustering', element);
                }).catch(function() {
                    document.getElementById('clusteringGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
                });
            } catch (e) {
                document.getElementById('clusteringGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
            }
        }

        function drawCouplingGraphViz(dot){
            try {
                const viz = new Viz();
                viz.renderSVGElement(dot).then(function(element) {
                    element.style.maxWidth = '100%'; element.style.height = 'auto'; element.style.width = '100%';
                    element.style.display = 'block'; element.style.margin = '0'; element.style.padding = '0';
                    element.classList.add('graphSvg');
                    document.getElementById('couplingGraph').appendChild(element);
                    addZoomControlsFor('coupling', element);
                }).catch(function() {
                    document.getElementById('couplingGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
                });
            } catch (e) {
                document.getElementById('couplingGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
            }
        }

        function drawCallingGraph(dot) {
            try {
                const viz = new Viz();
                viz.renderSVGElement(dot).then(function(element) {
                    element.style.maxWidth = '100%'; element.style.height = 'auto'; element.style.width = '100%';
                    element.style.display = 'block'; element.style.margin = '0'; element.style.padding = '0';
                    element.classList.add('graphSvg');
                    document.getElementById('graph').appendChild(element);
                    addZoomControlsFor('graph', element);
                }).catch(function() {
                    document.getElementById('graph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
                });
            } catch (e) {
                document.getElementById('graph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
            }
        }

        function drawModulesGraphViz(dot){
            try {
                const viz = new Viz();
                viz.renderSVGElement(dot).then(function(element) {
                    element.style.maxWidth = '100%'; element.style.height = 'auto'; element.style.width = '100%';
                    element.style.display = 'block'; element.style.margin = '0'; element.style.padding = '0';
                    element.classList.add('graphSvg');
                    document.getElementById('modulesGraph').appendChild(element);
                    addZoomControlsFor('modules', element);
                }).catch(function() {
                    document.getElementById('modulesGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
                });
            } catch (e) {
                document.getElementById('modulesGraph').innerHTML = '<b>Erreur lors du rendu du graphe.</b>';
            }
        }

        // Met à jour la visibilité des inputs X et CP selon le choix d'analyse
        function updateVisibility() {
            const type = document.getElementById('analysisType').value;
            const xContainer = document.getElementById('xContainer');
            const cpContainer = document.getElementById('cpContainer');
            const xInput = document.getElementById('x');
            const cpInput = document.getElementById('cp');
            const cpHint = document.getElementById('cpHint');
             // X visible uniquement pour 'all' ou 'statistics'
             if (type === 'all' || type === 'statistics') {
                 xContainer.style.display = 'inline-block';
                 if (xInput) xInput.disabled = false;
             } else {
                 xContainer.style.display = 'none';
                 if (xInput) xInput.disabled = true;
             }
             // CP visible uniquement pour 'all' ou 'modules'
             if (type === 'all' || type === 'modules') {
                 cpContainer.style.display = 'inline-block';
                 if (cpInput) {
                    // la valeur de CP impacte désormais le graphe de modules même pour 'all' => activer
                    cpInput.disabled = false;
                    if (cpHint) cpHint.textContent = '';
                 }
             } else {
                 cpContainer.style.display = 'none';
                 if (cpInput) cpInput.disabled = true;
                 if (cpHint) cpHint.textContent = '';
             }
         }
        // mettre à jour visibilité des inputs lors du changement de sélection
        document.getElementById('analysisType').addEventListener('change', function(e){
            updateVisibility();
        });
         // appeler au chargement pour initialiser l'état
         updateVisibility();
     </script>
</body>
</html>